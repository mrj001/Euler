; Arithmetic routines

!source "../libs/preamble.a"
!source "../libs/screen.a"

!zone arithmetic {
overflow !scr "integer overflow", 13, 0

; Compares two integers for equality
; Memory at the following labels is used
;    mathprec: number of bytes in each integer
;    mathop1: pointer to first integer to compare
;    mathop2: pointer to second integer to compare
;
; If they are equal the Z flag will be set 
; after execution; otherwise the Z flag will be cleared.
math_isequal:
    lda+1 mathprec  ; load count of bytes per integer
    tay             ; y will index the bytes of each integer
    dey             ; y should be zero-based.
.nextdigit
    lda (mathop1), y
    cmp (mathop2), y
    bne .end        ; not equal; return with Z flag cleared
    dey             ; will set/clear Z flag.
    bpl .nextdigit
    lda #$00        ; set Z flag
.end 
    rts

!zone add {
; This macro sets parameters for the math_add subroutine.
!macro set_param_add .a1, .a2, .sum {
   lda #<.a1         ; copy pointer for first addend
   sta mathop1
   lda #>.a1
   sta mathop1 + 1
   lda #<.a2         ; copy pointer for second addend
   sta mathop2
   lda #>.a2
   sta mathop2 + 1
   lda #<.sum        ; copy pointer for sum
   sta mathres
   lda #>.sum
   sta mathres + 1
}

; Add two unsigned integers
; Memory at the following labels is used
;    mathprec: number of bytes in each integer
;    mathop1: pointer to first addend
;    mathop2: pointer to second addend
;    mathres: pointer to memory for the sum
math_add:
   ldx mathprec;
   clc
   ldy #$00        ; y will be index into the addends
.nextdigit
   lda (mathop1), y  ; load byte of first addend
   adc (mathop2), y  ; add byte of second addend
   sta (mathres), y  ; store byte of sum
   iny
   dex
   bne .nextdigit
   bcs .error
   rts
.error
   lda #<overflow
   sta straddr
   lda #>overflow
   sta straddr + 1
   jsr subprint
   jmp $E37B       ; drop back to READY
}  ; end of zone add

!zone rotate_left {
; This macro sets parameters for the rotate left subroutine
!macro set_param_rol .a {
   lda #<.a
   sta mathop1
   lda #>.a
   sta mathop1 + 1
}

; Rotate an unsigned integer one bit to the left
; On return, the carry flag will contain the most 
; significant bit of the integer.
; Memory at the following labels is used
;    mathprec: number of bytes in each integer
;    mathop1:  pointer to the number to rotate
math_rol:
    ldx mathprec      ; x will be loop counter
    ldy #$00          ; y is an index into the integer's bytes
    lda (mathop1), y  ; shift the least significant byte
    asl
    sta (mathop1), y
.loop
    dex               ; check for end of loop
    beq .end
    iny               ; next byte
    lda (mathop1), y  ; shift a byte
    rol
    sta (mathop1), y
    jmp .loop
.end
    rts
}  ; end of zone rotate_left
}

